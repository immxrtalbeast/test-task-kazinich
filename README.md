#  RTP Multiplier
[![wakatime](https://wakatime.com/badge/user/42cf6868-b638-4d34-9e52-ec8f63476139/project/eb146a3a-6ad5-4e46-9c2d-cbbe29f4010c.svg)](https://wakatime.com/badge/user/42cf6868-b638-4d34-9e52-ec8f63476139/project/eb146a3a-6ad5-4e46-9c2d-cbbe29f4010c)

Если sum0 это количество всех начальных чисел последовательность, то GG WP!
## Новый алгоритм
Так как мы не знаем ничего кроме rtp, мы с шансом = rtp будем генерировать число около верхней границы, иначе число около нижней. Даже если все числа одинаковые, мы оставим ровно rtp% от всей суммы. Можно исключить рандомный фактор, чтобы избежать случая когда все числа равны 9999.9999 или 1.0001, тогда сервис вернёт только 10 000 или 1. Тестил на нормальном распределении, в случае когда все числа одинаковые, когда 80% = 9000, а 20% = 100.
```go
func (s *RTPMultiplierService) Generate() float64 {
	log := s.log.With(
		slog.Float64("rtp", s.targetRTP),
	)
	ran := rand.Float64()
	var ideal float64

	if ran > s.targetRTP {
		ideal = 1.0
	} else {
		ideal = 10000.0
	}
	randomFactor := 0.001
	low := ideal * (1.0 - randomFactor)
	high := ideal * (1.0 + randomFactor)
	multiplier := low + rand.Float64()*(high-low)
	if multiplier > 10000.0 {
		multiplier = 10000.0
	}
	if multiplier < 1.0 {
		multiplier = 1.0
	}
	rounded := math.Round(multiplier*10) / 10 //Округление если надо
	log.Info("Multiplier", slog.Float64("result", rounded))
	return rounded
}

```

## Алгоритм
Если sum0 сумма значений клиента, которые необходимо сравнить с multiplier, и все числа распределенны равномерно в списке sequence, то rtp можно представить как % от суммы чисел в sequence.
Тогда можно представить все числа sequence на прямой.<img width="1752" height="256" alt="image" src="https://github.com/user-attachments/assets/9eb4e0e2-8fd0-4bac-9865-15da59aef5b0" />
И если брать во внимание что в sum1 идут числа только меньше чем multiplier, нам остаётся взять точку(x1) на прямой и мы получим сумму чисел из sequence от 0 до x1.
<img width="1662" height="385" alt="image" src="https://github.com/user-attachments/assets/3afbc987-57a1-4fb8-b4f2-46dc90a427b3" />
Надо лишь знать куда ставить эту точку чтобы sum1 составляла примерно rtp% от sum0.

А Доля чисел, необходимых для достижения определённого процента суммы, равна квадратному корню из целевой доли.
Для 50% суммы требуется около 
sqrt(0.5)≈0.7071067
sqrt(0.7)≈0.8366600
Домножаем на 10000 т.к. по условию верхняя граница 10к и получаем точки для rtp.

Для rtp 0.5 точка будет находится на 7071.067

Для rtp 0.7 точка будет находится на 8366.600 и т.д.

Добавляем множители чтобы точка превратилась в отрезок 
```go
	ideal := math.Sqrt(s.targetRTP) * 10000.0
	low := ideal * 0.7
	high := ideal * 1.3
```
И всё! _(Если я правильно понял задание)_ Теперь у нас есть псевдо рандомные мультипликаторы которые на дистанции в 10000 итераций выдают погрешность около 0.02 единиц (Но это зависит от множителей верхней и нижней границ)
# Почему доля чисел, для достижения процента суммы, равна квадратному корню из целевой доли
- Сумма чисел от 1 до $N$ вычисляется по формуле  
$$S_N = \frac{N(N+1)}{2} \approx \frac{N^2}{2}$$  (для больших $N$).  

- Сумма чисел от 1 до $k$:	
$$S_k = \frac{k(k+1)}{2} \approx \frac{k^2}{2}.$$  

- Условие
- $$rtp$$ = 0.1,
- $$N$$ = 10000,		
$$S_k = 0.1 \cdot S_N$$  
приводит к соотношению:  

$$\frac{k^2}{2} \approx 0.1 \cdot \frac{N^2}{2} \implies k^2 \approx 0.1 \cdot N^2 \implies k \approx N \cdot \sqrt{0.1} \approx N \cdot 0.316 \approx 10.000 \cdot 0.316 \approx 3162.277$$

- Таким образом, чтобы захватить 10% суммы, поставить точку x1 на число 3162.277 (т.е. числа от $k$ до $N$, где $k \approx 0.316 \cdot N$).
#  Дополнение
Добавил логгирование от себя. Захардкодил порт. Так бы ещё добавил заваротку в докер, красивое логгирование, работу с конфигом. Graceful shutdown имеется.
Проверял себя путём создания массива randomFloats размером от 100 до 1.000.000 с рандомными floatами и вызовом функции GenerateMultiplier с созданием второго массива seq1 с числами меньше либо равными multiplier. Дальше делил sumSeq1 на sumRandomFloats.
